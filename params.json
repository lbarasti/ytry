{
  "name": "Ytry",
  "tagline": "A Scala inspired implementation of Try for Ruby",
  "body": "[![Gem Version](https://badge.fury.io/rb/ytry.svg)](https://badge.fury.io/rb/ytry)\r\n[![Build Status](https://travis-ci.org/lbarasti/ytry.svg?branch=master)](https://travis-ci.org/lbarasti/ytry) [![Coverage Status](https://coveralls.io/repos/github/lbarasti/ytry/badge.svg?branch=master)](https://coveralls.io/github/lbarasti/ytry?branch=master)\r\n\r\n# Ytry\r\n\r\nA [Scala](http://www.scala-lang.org/api/current/index.html#scala.util.Try) inspired gem that introduces `Try`s to Ruby while aiming for an idiomatic API.\r\n\r\n## Installation\r\n\r\nAdd this line to your application's Gemfile:\r\n\r\n```ruby\r\ngem 'ytry'\r\n```\r\n\r\nAnd then execute:\r\n\r\n    $ bundle\r\n\r\nOr install it yourself as:\r\n\r\n    $ gem install ytry\r\n\r\n## Basic usage\r\n\r\nThe Try type represents a computation that may either result in an error, or return a successfully computed value.\r\n\r\nIf the block passed to Try runs with no errors, then a `Success` wrapping the computed value is returned.\r\n\r\nAn instance of `Failure` wrapping the error is returned otherwise.\r\n\r\n```ruby\r\nrequire 'ytry'\r\ninclude Ytry\r\n\r\nTry { 1 + 1 } # Success(2)\r\n\r\nTry { 1 / 0 } # Failure(#<ZeroDivisionError: divided by 0>)\r\n```\r\n\r\n`Success` and `Failure` provide a unified API that lets us express a sequence of tranformations in a fluent way, without error handling cluttering the flow:\r\n\r\n```ruby\r\ndef load_and_parse json_file\r\n  Try { File.read(json_file) }\r\n    .map {|content| JSON.parse(content)}\r\n    .select {|table| table.is_a? Array}\r\n    .recover {|e| puts \"Recovering from #{e.message}\"; []}\r\nend\r\n\r\nload_and_parse(nonexisting_file) # prints \"Recovering from No such file...\" # Success([])\r\n\r\nload_and_parse(wrong_format_file) # prints \"Recovering from Element not found\" # Success([])\r\n\r\nload_and_parse(actual_file) # Success([{\"id\"=>1, \"name\"=>\"Lorenzo\", \"dob\"=>\"22/07/1985\"}])\r\n```\r\n\r\n`Try#map` and `Try#recover` are means to interact with the value wrapped by a Try in a safe way - i.e. with no risk of errors being raised.\r\n\r\n`Try#select` transforms a Success into a Failure when the underlying value does not satisfy the given predicate - i.e. the given block returns false. That can be useful when validating some input.\r\n\r\n`Try#get_or_else` provides a safe way of retrieving the possibly-missing value it contains. It returns the result of the given block when the Try is a Failure. It is equivalent to `Try#get` when the Try is a Success.\r\n\r\n```ruby\r\ninvalid_json = \"[\\\"missing_quote]\"\r\n\r\nTry { JSON.parse(invalid_json) }\r\n  .get_or_else{ [] } # []\r\n\r\nTry { JSON.parse(\"[]\") }\r\n  .get_or_else { fail \"this block is ignored\"} # []\r\n```\r\n\r\nIt is preferable to use `Try#get_or_else` over `Try#get`, as `#get` will raise an error when called on a Failure. It is possible to check for failure via `#empty?`, but that tipically leads to non-idiomatic code\r\n\r\n## Why Try?\r\n\r\nUsing Try instead of rescue blocks can make your software both clearer and safer as it\r\n\r\n- leads to less verbose error handling\r\n- simplifies the way we deal with operations that might fail for several reasons (such as IO operations)\r\n- privileges method chaining thus reducing the need for auxiliary variables to store intermediate results in a computation\r\n- encourages programming towards immutability, where the data is transformed rather than mutated in place.\r\n\r\n\r\n## License\r\n\r\nThe gem is available as open source under the terms of the [MIT License](http://opensource.org/licenses/MIT).\r\n",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}